# Inline Functions

- When you use the `inline` keyword besides a higher-order function, what happens is instead of creating an instance of the function argument, the code inside the function argument is copied inline in the generated code, thereby saving unnecessary allocation of memory for function creation and variables used inside of the function argument.

- Let's say you create a higher order function that takes a lambda of type () -> Unit (no parameters, no return value), and executes it like so:
```
fun nonInlined(block: () -> Unit) {
    println("before")
    block()
    println("after")
}
```
In Java parlance, this will translate to something like this (simplified!):
```
public void nonInlined(Function block) {
    System.out.println("before");
    block.invoke();
    System.out.println("after");
}
```
And when you call it from Kotlin...
```
nonInlined {
    println("do something here")
}
```
Under the hood, an instance of Function will be created here, that wraps the code inside the lambda (again, this is simplified):
```
nonInlined(new Function() {
    @Override
    public void invoke() {
        System.out.println("do something here");
    }
});
```
So basically, calling this function and passing a lambda to it will always create an instance of a Function object.

On the other hand, if you use the inline keyword:
```
inline fun inlined(block: () -> Unit) {
    println("before")
    block()
    println("after")
}
```
When you call it like this:
```
inlined {
    println("do something here")
}
```
No Function instance will be created, instead, the code around the invocation of block inside the inlined function will be copied to the call site, so you'll get something like this in the bytecode:
```
System.out.println("before");
System.out.println("do something here");
System.out.println("after");
```
In this case, no new instances are created.

- Let me add: "When not to use inline":

1) If you have a simple function that doesn't accept other functions as an argument, it does not make sense to inline them. IntelliJ will warn you:

Expected performance impact of inlining '...' is insignificant. Inlining works best for functions with parameters of functional types

2) Even if you have a function "with parameters of functional types", you may encounter the compiler telling you that inlining does not work. Consider this example:

inline fun calculateNoInline(param: Int, operation: IntMapper): Int {
    val o = operation //compiler does not like this
    return o(param)
}
This code won't compile with the error:

Illegal usage of inline-parameter 'operation' in '...'. Add 'noinline' modifier to the parameter declaration.

The reason is that the compiler is unable to inline this code. If operation is not wrapped in an object (which is implied by inline since you want to avoid this), how can it be assigned to a variable at all? In this case, the compiler suggests making the argument noinline. Having an inline function with a single noinline function does not make any sense, don't do that. However, if there are multiple parameters of functional types, consider inlining some of them if required.

So here are some suggested rules:

* You can inline when functional type param is called directly or passed to other inline function
* You should inline when ^ is the case.
* You cannot inline when function parameter is being assigned to variable inside function
* You should consider inlining if at least one of your functional typed parameters can be inlined, use noinline for the rest.
* You should not inline huge functions, think about generated byte code. It will be copied to all places the function is called from.
* Another use case is reified type parameters, which require you to use inline

[Reference](https://stackoverflow.com/q/44471284/4291698)
